I have a topic that contains the following most representative documents:
<sentence0>In a spring boot, I have to services implementing the same interface. How to load one service or another by a property key?</sentence0>
<sentence1>How to add a java class in a generic container from testcontainers in order to run later</sentence1>
<sentence2>How to run a java class inside of a container with testcontainers?</sentence2>
<sentence3>How using this example, public class Main {      public static void main(String[] args) {          Connector connector = new Connector();         connector.setPort(8080);          Tomcat tomcat = new Tomcat();         tomcat.getService().addConnector(connector);          File base = new File(System.getProperty("java.io.tmpdir"));         Context context = tomcat.addContext("", base.getAbsolutePath());          HttpServlet myServlet = new MyServlet();         Wrapper servletWrapper = Tomcat.addServlet(context, "MyServlet", myServlet);         servletWrapper.addMapping("/hello");          try {             tomcat.start();             tomcat.getServer().await();         } catch (LifecycleException e) {             e.printStackTrace();         }     } } how to add JSP support programaticatically?</sentence3>
<sentence4>I got an error when I start my test in spring boot application. This is my test code:  @Test     public void deserializerTest() throws JsonProcessingException {         // given         // create data and serialization         Point location = new Point(35.17, 15.36);         StoreSqsDto sendingStoreSqsDto = new StoreSqsDto("storeId123", "good pizza", FoodKind.PIZZA, "0100001010", "somewhere", "room102", location, "Hello. We are good pizza.", false);         JSONObject jsonObject = new JSONObject();         JSONObject sendingData = new JSONObject(sendingStoreSqsDto);         jsonObject.put("dataType", "store");         jsonObject.put("method", "create");         jsonObject.put("data", sendingData);          // when         // deserialization         String receivedData = jsonObject.get("data").toString();         ObjectMapper objectMapper = new ObjectMapper();         StoreSqsDto receivedStoreSqsDto = objectMapper.readValue(receivedData, StoreSqsDto.class);          // then         assertThat(receivedStoreSqsDto.getStoreId()).isEqualTo(sendingStoreSqsDto.getStoreId());         assertThat(receivedStoreSqsDto.getLocation()).isEqualTo(sendingStoreSqsDto.getLocation());     }   And this is StoreSqsDto.class:    package msa.customer.dto.store;  import lombok.Getter; import lombok.NoArgsConstructor; import lombok.Setter; import msa.customer.entity.store.FoodKind; import org.springframework.data.geo.Point;  @Getter @Setter @NoArgsConstructor public class StoreSqsDto {     private String storeId;     private String name;     private FoodKind foodKind;     private String phoneNumber;     private String address;     private String addressDetail;     private Point location;     private String introduction;     private Boolean open;      public StoreSqsDto(String storeId, String name, FoodKind foodKind, String phoneNumber, String address, String addressDetail, Point location, String introduction, Boolean open) {         this.storeId = storeId;         this.name = name;         this.foodKind = foodKind;         this.phoneNumber = phoneNumber;         this.address = address;         this.addressDetail = addressDetail;         this.location = location;         this.introduction = introduction;         this.open = open;     } }  When I start to run the test, I got this error log:  Cannot construct instance of `org.springframework.data.geo.Point` (no Creators, like default constructor, exist): cannot deserialize from Object value (no delegate- or property-based Creator)  What is the reason of this? And how can I fix that?</sentence4>
<sentence5>Given this example: import java.io.File; import org.apache.catalina.connector.Connector; import org.apache.catalina.Context; import org.apache.catalina.LifecycleException; import org.apache.catalina.Wrapper; import org.apache.catalina.startup.Tomcat; import org.springframework.context.annotation.Configuration; import org.springframework.web.servlet.DispatcherServlet; import org.springframework.web.bind.annotation.RestController; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.context.annotation.ComponentScan; import org.springframework.web.context.support.AnnotationConfigWebApplicationContext; import jakarta.annotation.PostConstruct;  public class Main {      public static void main(String[] args) throws Exception {          Connector connector = new Connector();         connector.setPort(8080);          Tomcat tomcat = new Tomcat();         tomcat.getService().addConnector(connector);          File base = new File(System.getProperty("java.io.tmpdir"));         Context context = tomcat.addContext("", base.getAbsolutePath());          AnnotationConfigWebApplicationContext appContext = new AnnotationConfigWebApplicationContext();         appContext.register(SpringConfig.class);         appContext.refresh();          DispatcherServlet dispatcherServlet = new DispatcherServlet(appContext);         Wrapper wrapper = context.createWrapper();         wrapper.setName("dispatcherServlet");         wrapper.setServlet(dispatcherServlet);         context.addChild(wrapper);         wrapper.setLoadOnStartup(1);         wrapper.addMapping("/");          try {             tomcat.start();             tomcat.getServer().await();         } catch (LifecycleException e) {             e.printStackTrace();         }     } how to update to process a JSP?</sentence5>
<sentence6>Make this Java code into Android Java code so that it looks like online multiplayer Android game and also their respective XML layout Write a full step by step code  Main.java package org.example;  public class Main {     public static void main(String[] args) {         new Game();     } }  Game.java package org.example;  import java.util.Scanner;  /* * Handles the overall flow of the game. * It prompts the player for game mode selection, creates instances of other necessary classes, and orchestrates the gameplay. */ public class Game {     boolean singlePlayer;     Player player;     ComputerPlayer computerPlayer;     GameLogic gameLogic;      /*     * Initializes the game by displaying a welcome message, setting the game mode,     * creating instances of other necessary classes (Player, ComputerPlayer, and GameLogic), and starting the game.*/     public Game() {         System.out.println("Welcome to RPS Arena!\n");         setGameMode();         gameLogic = new GameLogic();         startGame();     }      /**      * Prompts the player to select the game mode (single-player or multiplayer).      * Sets the 'singlePlayer' variable based on the user input.      */     private void setGameMode() {         Scanner userInput = new Scanner((System.in));         System.out.println("Select Game Mode!\n");         System.out.println("1. Single-player");         System.out.println("2. Multiplayer\n");          String input = userInput.nextLine();         if (input.equalsIgnoreCase("1")) {             singlePlayer = true;             System.out.println("You have selected Single-player mode!\n");             player = new Player();             computerPlayer = new ComputerPlayer();         } else if (input.equalsIgnoreCase("2")) {             singlePlayer = false;         } else if (input.equalsIgnoreCase("exit")) {             System.out.println("Exiting APS Arena...");             System.exit(0);         }         else {             setGameMode();         }     }      /*     * Handles the main game loop. It repeatedly prompts the player for their move, checks if the input is "exit" to exit the game,     * converts the input to a Moves enum value, generates the opponent's move (either by the computer in single-player mode or by     * the other player in multiplayer mode), determines the winner using GameLogic, updates the points for the players, and displays     * the result and current points.*/     private void startGame() {         while (true) {             System.out.println("Enter your move or type 'exit' to quit the game:");             System.out.println("Moves: ROCK, PAPER, SCISSORS");             String input = getPlayerInput();              if (input.equalsIgnoreCase("exit")) {                 System.out.println("\nExiting RPS Arena...");                 System.exit(0);             }              Moves playerMove = convertToMove(input);             if (playerMove == null) {                 System.out.println("Invalid move. Please try again.");                 continue;             }              Moves opponentMove;             if (singlePlayer) {                 opponentMove = computerPlayer.generateCPUMove();                 System.out.println("\nComputer played: " + opponentMove);             } else {                 opponentMove = player.getOpponent().getPlayerMove();                 System.out.println(player.getOpponent().getUsername() + " played: " + opponentMove);             }              String result = gameLogic.determineWinner(playerMove, opponentMove);             System.out.println("Result: " + result);             updatePoints(result);         }     }      /*     * Prompts the player to enter their move or type "exit" to quit the game and returns the input as a String.*/     private String getPlayerInput() {         Scanner userInput = new Scanner(System.in);         return userInput.nextLine().toUpperCase();     }      /*     * converts the input String to a corresponding Moves enum value. It tries to match the input with the available     * Moves enum values (ROCK, PAPER, SCISSORS) and returns the matched enum value. If the input doesn't match any     * enum value, it returns null.*/     private Moves convertToMove(String input) {         try {             return Moves.valueOf(input);         } catch (IllegalArgumentException e) {             return null;         }     }      /*     * updates the points for the players based on the game result.     * If the result is "WIN," it increments the player's points and displays a message indicating the player's win.     * If the result is "LOSS," it increments the opponent's points (computer in single-player or the other player in multiplayer)     * and displays a message indicating the opponent's win.     * If the result is a tie, it displays a message indicating a tie. It then prints the current points for both players.*/     private void updatePoints(String result) {         if (result.equals("WIN")) {             player.incrementPoints();             System.out.println(player.getUsername() + " wins!");         } else if (result.equals("LOSS")) {             if (singlePlayer) {                 computerPlayer.incrementPoints();                 System.out.println("Computer wins!");             } else {                 player.getOpponent().incrementPoints();                 System.out.println(player.getOpponent().getUsername() + " wins!");             }         } else {             System.out.println("It's a tie!");         }          System.out.println("\nPoints:");         System.out.println(player.getUsername() + ": " + player.getPlayerPoints());         if (!singlePlayer) {             System.out.println(player.getOpponent().getUsername() + ": " + player.getOpponent().getPlayerPoints());         } else {             System.out.println("Computer: " + computerPlayer.getCpuPoints());         }         System.out.println();     } }  GameLogic.java package org.example;  /* * Contains the game rules and logic. * It determines the winner based on the moves chosen by the players.*/ public class GameLogic {      /**      * Determines the winner of the game based on the moves played by the player and the CPU.      *      * @param playerMove The move played by the player.      * @param cpuMove    The move played by the CPU.      * @return A string indicating the result of the game: "WIN" if the player wins, "LOSS" if the player loses, or "TIE" if it's a tie.      */     public String determineWinner(Moves playerMove, Moves cpuMove) {         if (playerMove == cpuMove) {             return "TIE";         } else if (playerMove.equals(Moves.ROCK) && cpuMove.equals(Moves.PAPER) ||                     playerMove.equals(Moves.PAPER) && cpuMove.equals(Moves.SCISSORS) ||                     playerMove.equals(Moves.SCISSORS) && cpuMove.equals(Moves.ROCK)) {             return "LOSS";         } else {             return "WIN";         }     } }  Moves.java package org.example;  public enum Moves {     ROCK,     PAPER,     SCISSORS }  ComputerPlayer.java package org.example;  import java.util.Random;  /* * Extends the Player class and represents the computer player in single-player mode. * It implements a strategy to generate a random move for the computer.*/ public class ComputerPlayer {     private int cpuPoints = 0;      /**      * @return returns the points of the computer*/     public int getCpuPoints() {         return cpuPoints;     }       /**      *  Increments the points of the computer*/     public void incrementPoints() {         cpuPoints++;     }       /**      * Generates a random move for the computer player.      *      * @return A random move from the Moves enum.      */     public Moves generateCPUMove() {         Moves[] moves = Moves.values();         Random random = new Random();         int index = random.nextInt(moves.length);         return moves[index];     } }  HumanPlayer.java package org.example;  /**  *  Extends the Player class and represents a human player in multiplayer mode.  *  It can handle input from the human player to get their move.*/ public class HumanPlayer { }  Player.java package org.example;  import java.util.Scanner;  /**  * Represents a player in the game.  * It has properties such as name and points.  * It provides methods to get the player's move and update their points.*/ public class Player {     String username;     int playerPoints;     private Player opponent;      /*     * Initializes a player by prompting them to enter their username, setting the initial points to 0, and displaying a greeting message.*/     public Player() {         this.playerPoints = 0;         this.username = promptUsername();         System.out.println("Hello " + username + "!\n");     }      /*     *  Sets the opponent of the player. It takes a Player object as a parameter and assigns it to the opponent field of the player.*/     public void setOpponent(Player opponent) {         this.opponent = opponent;     }       /**     * @return the opponent of the player.     */     public Player getOpponent() {         return opponent;     }       /**      * @return returns the username of the player*/     public String getUsername() {         return username;     }      /**      * @return returns the points of the player*/     public int getPlayerPoints() {         return playerPoints;     }      /**      *  Increments the points of the player*/     public void incrementPoints() {         playerPoints++;     }      /**      * Prompts the player to enter their username.      *      * @return The username entered by the player.      */     private String promptUsername() {         Scanner userInput = new Scanner((System.in));         System.out.println("What's your username?");         return userInput.nextLine();     }      /**      * Prompts the player to enter their move (Rock, Paper, or Scissors).      * If the user input is not valid, the player is prompted again until a valid move is entered.      *      * @return The valid move entered by the player.      */     public Moves getPlayerMove() {         System.out.println("Rock, Paper or Scissors?\n");         Scanner userInput = new Scanner((System.in));         String input = userInput.nextLine().toUpperCase();          if (input.equals(Moves.ROCK.toString()) || input.equals(Moves.PAPER.toString()) || input.equals(Moves.SCISSORS.toString())) {             return Moves.valueOf(input);         } else {             System.out.println("Invalid move. Please try again.");             return getPlayerMove();         }     } }  </sentence6>
<sentence7>Given a Java class how to retrieve the public methods programmatically?</sentence7>
<sentence8>Given a class name runnning in Spring, how to get the package?</sentence8>
<sentence9>Provide base object class. Create a factory class that creates objects of the base class. Make one of the factory methods accept a class to instantiate. This class must extend the base class. Language is java</sentence9>


The topic is described by the following keywords: java, tomcat, objectmapper, myservlet, systemoutprintlnplayergetopponentgetusername, class, jsonobject, bean, gamelogic, maven,

Based on the information about the topic above, 
1) Analyze the keywords and come up with a general label. Explain why? 
2) cluster the most representative sentences to come up with sub-labels. Explain why? 

DO NOT FORGET TO include the first 10 character of that sentences that you use to come up with that sub-category, so that I can read the sentences you have clustered and see if you come up with correct label for that. 
Take your time and think, then come up with the best, precise, and meaningful label and sub-labels.

Now Take a deep breath and start