I have a topic that contains the following most representative documents:
<sentence0>I want this game to rely on local storage to remember who I am and who my picks were in previous contests. A contest is January, March, May, July, September, or November of a given year. The current contest is July 2023. We will assume I am in admin mode and I can switch users to record everyone's picks (which are visible to everyone) and backfill old results. Please add at least one new test.  index.html        Banzuke Surfing Game                     -->       Welcome to Banzuke Surfing Game!     Select your Rikishi and start playing!              Rikishi 1         Rikishi 2                   Start Playing              game.js function startPlaying() {     var rikishi = $('#rikishi').val();     var message = "You selected: " + rikishi;     return message; }  module.exports = { startPlaying };  game.test.js  global.$ = jest.fn(() => ({     val: jest.fn(() => '1') }));  const { startPlaying } = require('./game');  test('check if startPlaying is defined and returns expected value', () => {     const result = startPlaying()     expect(result).toBe("You selected: 1"); });</sentence0>
<sentence1>I need some place on the page to render the contents of localStorage on every page load. After I get this working I will want to add to my unit tests to ensure that this will always happen.  index.html        Banzuke Surfing Game                     -->       Welcome to Banzuke Surfing Game!          Select your Rikishi and start playing!              Rikishi 1         Rikishi 2                   Start Playing          Backfilled Results:          Admin Panel     Switch user:          Switch User     Backfill contest results:               Backfill Results                   game.js export default class Game {     constructor(initializeImmediately = false) {         this.user = this.getUser();         if (initializeImmediately) {             this.initialize();         }     }      startPlaying() {         const rikishi = document.querySelector('#rikishi').value;         const picks = this.getPicks();         const message = "You selected: " + rikishi + "\nPrevious Picks: " + JSON.stringify(picks);         this.updatePicks(rikishi); // Update the picks with the new selection         return message;     }      getUser() {         // get user from local storage         let user = localStorage.getItem('user');         if (!user) {             user = 'admin';             localStorage.setItem('user', user);         }         return user;     }      getPicks() {         const picks = JSON.parse(localStorage.getItem(this.user));         if (!picks) {             return {};         }         return picks;     }      updatePicks(rikishi) {         const picks = this.getPicks();         const currentContest = new Date().getMonth();         if ([0, 2, 4, 6, 8, 10].includes(currentContest)) {             const contestName = new Date().toLocaleString('default', { month: 'long' }) + ' ' + new Date().getFullYear();             picks[contestName] = rikishi;             localStorage.setItem(this.user, JSON.stringify(picks));         }     }      switchUser() {         const newUser = document.querySelector('#userSwitch').value;         localStorage.setItem('user', newUser);         document.querySelector('#user').textContent = 'Current user: ' + newUser;         this.user = newUser;     }      backfillResults() {         const contestName = document.querySelector('#backfillContest').value;         const rikishi = document.querySelector('#backfillRikishi').value;         const picks = this.getPicks();         picks[contestName] = rikishi;         localStorage.setItem(this.user, JSON.stringify(picks));         this.provideFeedback('Backfilled results for ' + contestName + ' with ' + rikishi); // Provide feedback         this.displayBackfilledResults(); // Display the updated results     }      displayBackfilledResults() {         const picks = this.getPicks();         const resultsElement = document.querySelector('#backfilledResults');          // Clear previous results         resultsElement.textContent = '';          // Display each contest result         for (const contest in picks) {             const rikishi = picks[contest];             const resultText = document.createTextNode(contest + ': ' + rikishi);             const resultDiv = document.createElement('div');             resultDiv.appendChild(resultText);             resultsElement.appendChild(resultDiv);         }     }      provideFeedback(message) {         document.querySelector('#feedback').textContent = message;     }      initialize() {         const userElement = document.querySelector('#user');         if (userElement) {             userElement.textContent = 'Current user: ' + this.user;         }         this.displayBackfilledResults(); // Display the initial results          // Add event listeners         document.querySelector("#startPlayingButton").addEventListener('click', () => this.startPlaying());         document.querySelector("#switchUserButton").addEventListener('click', () => this.switchUser());         document.querySelector("#backfillResultsButton").addEventListener('click', () => this.backfillResults());     } }  if (typeof window !== 'undefined') {     window.game = new Game(); }</sentence1>
<sentence2>const fs = require('fs'); const multer = require('multer'); const puppeteer = require('puppeteer'); const express = require('express'); const app = express(); const port = 3001; const path = require('path'); const storage = multer.diskStorage({   destination: function(req, file, cb) {     cb(null, 'uploads/')   },   filename: function(req, file, cb) {     const date = new Date();     const formattedDate = `${date.getFullYear()}${date.getMonth() + 1}${date.getDate()}${date.getHours()}${date.getMinutes()}${date.getSeconds()}`;     const fileName = `${formattedDate}_${file.originalname}`;     cb(null, fileName);   } }); const upload = multer({ storage: storage }); const serveIndex = require('serve-index');  // app.use('/generated', express.static(path.join(__dirname, 'generated')), serveIndex(path.join(__dirname, 'generated'), {'icons': true})); // app.use('/uploads', express.static(path.join(__dirname, 'uploads')), serveIndex(path.join(__dirname, 'uploads'), {'icons': true}));  app.post('/api/upload', upload.single('file'), (req, res) => {   const {bookName, fontSize, papersCount} = req.query;    const date = new Date();   const id = `${date.getFullYear()}${date.getMonth() + 1}${date.getDate()}${date.getHours()}${date.getMinutes()}${date.getSeconds()}_${bookName}_${fontSize}`;    function writeToInProgress(text) {     console.log(`${text}`);     const inProgressPath = path.join(__dirname, 'generated', `IN_PROGRESS_${id}.txt`);     fs.writeFileSync(inProgressPath, text);   }    setImmediate(async () => {     try {       await run(req, id, bookName, fontSize);     } catch (error) {       console.error(error);       writeToInProgress('ERROR: ' + error.toString());     }   });    async function run(req, id, bookName, fontSize) {     const browser = await puppeteer.launch({       protocolTimeout: 1000000     });     const page = await browser.newPage();     const inProgressPath = path.join(__dirname, 'generated', `IN_PROGRESS_${id}.txt`);      page.on('console', pageIndex => {       writeToInProgress(`Creating sheet ${pageIndex.text() / 2} of ${papersCount}-ish.`);     });      // await page.setViewport({ width: 816, height: 1056 });      let text = fs.readFileSync(req.file.path, 'utf8');          await page.goto(`file://${__dirname}/page.html`);          await page.addStyleTag({content: `body { font-size: ${fontSize}px; }`});      writeToInProgress(`Creating: ${bookName}`);      await page.evaluate((text, bookName) => {       let pageIndex = 0;       let isCurrentPageFront = true; // tracks whether the next page to be rendered is on the front of the double sided sheet. the side with the big header        function createNewPage(wordsLeft) {         console.log(pageIndex+1);         const page = document.createElement('div');         page.className = 'page';          // create grid cells         const grid = document.createElement('div');         grid.className = 'grid-container';         for (let i = 0; i = 4 && i  currentBlock.clientHeight) {           currentBlock.innerHTML = currentBlock.innerHTML.slice(0, currentBlock.innerHTML.length - words[i].length);            // Move to the next block           currentBlockIndex++;           if (currentBlockIndex >= blocks.length) {             createNewPage(words.length - i); // Create a new page if all blocks are filled             currentBlockIndex = blocks.length - 16; // Reset the block index to the first block of the new page           }           currentBlock = blocks[currentBlockIndex];           currentBlock.innerHTML += ' ' + words[i]; // Add the word to the new block         }       }        // Populate headers       const SHEETS_AMOUNT = Math.ceil(pageIndex / 2);       isCurrentPageFront = true;       for (let i = 0; i  {         const cloneBlock = block.cloneNode(true);         const spanElement = cloneBlock.querySelector('.miniSheetNum');         if (spanElement) {           spanElement.remove();         }         if (cloneBlock.textContent.trim() === '') {           block.remove();         }       });     }, text, bookName);      writeToInProgress('Finished creating pages. Writing to file...');      let htmlContent = await page.content();     const pageHtml = path.join(__dirname, `pageHtml.html`);     fs.writeFileSync(pageHtml, htmlContent);      const pdf = await page.pdf({ format: 'Letter' });     const pdfOutput = path.join(__dirname, 'generated', `${id}.pdf`);     fs.writeFileSync(pdfOutput, pdf);      await browser.close();      // Delete the IN_PROGRESS file after PDF is created     if (fs.existsSync(inProgressPath)) {       fs.unlinkSync(inProgressPath);     }   }      res.json({ message: 'PDF creation started.', id }); });  app.get('/api/download/', (req, res) => {   const { id } = req.query;   const pdfOutput = path.join(__dirname, 'generated', `${id}.pdf`);   const inProgressPath = path.join(__dirname, 'generated', `IN_PROGRESS_${id}.txt`);    if (fs.existsSync(pdfOutput)) {     res.redirect(`/generated/${id}.pdf`);   } else if (fs.existsSync(inProgressPath)) {     res.send(fs.readFileSync(inProgressPath, 'utf8'));   } else {     return res.send('Not started. It\'s either in the queue, or failed entirely.');   } });  app.listen(port, () => {   console.log(`Listening on port ${port}`); });   how could i improve the readability of this? what can be moved to different files for example and how</sentence2>
<sentence3>server.js // Required libraries import cors from 'cors'; import axios from 'axios'; import fs from 'fs'; import express from 'express'; import  from '  // Define HTTPS credentials using the File System (fs) to read the key and certificate files const options = {   key: fs.readFileSync('/opt/bitnami/apache/conf/mindfulai.equalreality.com.key'),   // Path to private key   cert: fs.readFileSync('/opt/bitnami/apache/conf/mindfulai.equalreality.com.crt')   // Path to certificate file };  // Create an instance of an Express application const app = express();  let promptResponse = {};  //API's import PromptGPT from './PromptGPT.js'; import { Speak, ResetCache } from './ElevenLabsServer.js';  import Transcribe from './WhisperTranscriberServer.js';   // Use cors middleware for handling Cross-Origin Resource Sharing app.use(cors());  // Tell Express to parse JSON in the body of incoming requests. app.use(express.json());  // Log all incoming requests app.use(function(req, res, next) {     console.log(`${req.method} request for '${req.url}'`);     next();  // Pass control to the next middleware function });  // Use the 'Speak' function as a route handler for the '/Speak' route - Eleven Labs app.post('/Speak', Speak);  //Use the 'Transcribe' function as a route handler for the '/Transcribe' route - Whisper OpenAI app.post('/Transcribe', Transcribe);  // Restart the server app.get('/Restart', function (req, res) {     //Restart(); });  // Call to GPT for older version of JudgeGPT app.post('/AskGPT', function (req, res) {     // Log the body of the request     console.log(req.body);      // Extract youtubeId from the request body     const prompt = req.body.prompt;      // Log the prompt     console.log(prompt);      // Create a new OpenAI Reponse with prompt     promptResponse[prompt] = new PromptGPT(prompt);      // Get the response      promptResponse[prompt].AskGPT().then((data) => {         console.log(data);         console.log(data.generatedText);         res.json({ //why not make res.json = data             generatedText: data.generatedText,             inputPrompt: data.inputPrompt         });     })     .catch((error) => {         // If there is an error, log it and send a response         console.error(error);         res.json("error");     });  });  // Define the port and HTTPS server options const port = 3000;  // Define server port. Note: HTTPS servers typically use port 443 by default.  // Create and start the HTTPS server var server =  app).listen(port, () => {     console.log(`Secure server is running on port ${port}`); });  WhisperTranscriberServer.js // - How to use whisper // - Redesigning it for Node  // Import necessary modules import fetch from 'node-fetch'; import FormData from 'form-data'; import multer from 'multer'; import * as ENV from './env.js';   // Extract API key from ENV const OPENAI_API_KEY = ENV.OPENAI_API_KEY;  // Initialize multer middleware const upload = multer();  // Set up the middleware and route handler export default [upload.single('file'), async (req, res) => {      // Extract the audio file from the request     const audioFile = req.file;      // Log the received file for debugging purposes     console.log(audioFile);       // Create the form data to send to the Whisper API     const formData = new FormData();     formData.append('file', audioFile.buffer, { filename: 'audio.wav', contentType: 'audio/wav' });     formData.append('model', 'whisper-1');      // Make the API request     try {         const response = await fetch(' {             method: 'POST',             headers: {                 'Authorization': 'Bearer ' + OPENAI_API_KEY,                 ...formData.getHeaders(),             },             body: formData,         });          if (!response.ok) {             throw new Error('API response was not ok. Status: ' + response.status);         }          const data = await response.json();         if (data.text) {             // Send the transcription back in the response             res.json({ transcription: data.text });         } else if (data.status === 'processing') {             // For simplicity, let's just send a message back             res.json({ message: 'Transcription is still processing' });         }     } catch (error) {         // Send the error message back in the response         res.json({ error: error.message });     } }];  PromptGPT.js import fs from 'fs'; import axios from 'axios'; import * as ENV from './env.js';  const OPENAI_API_KEY = ENV.OPENAI_API_KEY;  class PromptGPT {   constructor(inputPrompt)    {      this.status = {       finished: false,       generatedText: "",       startTime: new Date(),       completeTime: "",       inputPrompt: ""     };      this.inputPrompt = inputPrompt;      this.callbacks = [];    }    // Add a function to add a callback   addCallback(callback) {     this.callbacks.push(callback);   }    async AskGPT() {     return new Promise((resolve, reject) => {       console.log(this.inputPrompt);          const maxTokens = 200;         const model = "text-davinci-003";//"gpt-3.5-turbo";//"text-davinci-003";          axios.post(' {           model,           prompt: this.inputPrompt,           max_tokens: maxTokens,         }, {           headers: {             'Authorization': `Bearer `+OPENAI_API_KEY,             'Content-Type': 'application/json',           },         }).then((response) => {            this.status.finished = true;           this.status.generatedText = response.data.choices[0].text.trim();           this.status.completeTime = new Date();           this.status.inputPrompt = this.inputPrompt;            // Invoke all registered callbacks           for (const callback of this.callbacks) {             try {               callback(null, status);             } catch (e) {               console.error('Error invoking callback:', e);             }           }            console.log("returning generated text" + this.status );           resolve(this.status);          }).catch((error) => {           reject(error);         });      });   } }  exports default PromptGPT;  ElevenLabsServer.js import axios from 'axios'; import * as ENV from './env.js';  const ELEVENLABS_API_KEY = ENV.ELEVENLABS_API_KEY;  var audioCache = new Map(); // Create a cache to store audio results  const Speak = async (req, res) => {     console.log("Speak");     const text = req.body.text;     var voiceId;      if(req.body.voiceId == null || req.body.voiceId == "")         voiceId = '21m00Tcm4TlvDq8ikWAM';  // default voice     else         voiceId = req.body.voiceId;      const cacheKey = `${text}-${voiceId}`; // Create a unique key based on text and voiceId      // If audio data is in cache, send it     if(audioCache.has(cacheKey)) {         return res.send(audioCache.get(cacheKey));     }      console.log("VoiceId " + voiceId);      const headers = {         'Accept': 'audio/mpeg',         'xi-api-key': ELEVENLABS_API_KEY,         'Content-Type': 'application/json'     };      const body = JSON.stringify({         text: text,         model_id: 'eleven_monolingual_v1',         voice_settings: {             stability: 0.5,             similarity_boost: 0.5         }     });      try {         const response = await axios.post(` body, {             headers: headers,             responseType: 'arraybuffer'  // This is important for handling binary data         });          const audio = Buffer.from(response.data, 'binary');          audioCache.set(cacheKey, audio); // Store the audio data in cache          res.send(audio);     } catch(err) {         // Handle any error that occurred during the API call         console.error("Error fetching audio:", err);         res.status(500).send('Failed to generate audio');     } };  // Function to reset the cache const ResetCache = () => {     audioCache.clear();     console.log("Audio cache has been cleared"); };  export { Speak, ResetCache };</sentence3>
<sentence4>I like how I get some of localStorage rendered on startup - but it only shows me stuff for 1 user.  Please make a choice and commit to it,you can either (1) restructure code by adding more javascript classes or (2) work with the existing code and render all of localStorage on page load. Bearing in mind that game.js appears to be scoped to one user, which is inconvenient. Please decide if you will do 1 or 2, then execute on that line of thought.         Banzuke Surfing Game                     -->       Welcome to Banzuke Surfing Game!          Select your Rikishi and start playing!              Rikishi 1         Rikishi 2                   Start Playing          Backfilled Results:          Admin Panel     Switch user:          Switch User     Backfill contest results:               Backfill Results                        import { Game } from './game.js';         window.game = new Game();         window.game.initialize();         game.js export default class Game {     constructor() {         this.user = this.getUser();     }      startPlaying() {         const rikishi = document.querySelector('#rikishi').value;         const picks = this.getPicks();         const message = "You selected: " + rikishi + "\nPrevious Picks: " + JSON.stringify(picks);         this.updatePicks(rikishi); // Update the picks with the new selection         return message;     }      getUser() {         // get user from local storage         let user = localStorage.getItem('user');         if (!user) {             user = 'admin';             localStorage.setItem('user', user);         }         return user;     }      getPicks() {         const picks = JSON.parse(localStorage.getItem(this.user));         if (!picks) {             return {};         }         return picks;     }      updatePicks(rikishi) {         const picks = this.getPicks();         const currentContest = new Date().getMonth();         if ([0, 2, 4, 6, 8, 10].includes(currentContest)) {             const contestName = new Date().toLocaleString('default', { month: 'long' }) + ' ' + new Date().getFullYear();             picks[contestName] = rikishi;             localStorage.setItem(this.user, JSON.stringify(picks));         }     }      switchUser() {         const newUser = document.querySelector('#userSwitch').value;         localStorage.setItem('user', newUser);         document.querySelector('#user').textContent = 'Current user: ' + newUser;         this.user = newUser;     }      backfillResults() {         const contestName = document.querySelector('#backfillContest').value;         const rikishi = document.querySelector('#backfillRikishi').value;         const picks = this.getPicks();         picks[contestName] = rikishi;         localStorage.setItem(this.user, JSON.stringify(picks));         this.provideFeedback('Backfilled results for ' + contestName + ' with ' + rikishi); // Provide feedback         this.displayBackfilledResults(); // Display the updated results     }      displayBackfilledResults() {         const picks = this.getPicks();         const resultsElement = document.querySelector('#backfilledResults');          // Clear previous results         resultsElement.textContent = '';          // Display each contest result         for (const contest in picks) {             const rikishi = picks[contest];             const resultText = document.createTextNode(contest + ': ' + rikishi);             const resultDiv = document.createElement('div');             resultDiv.appendChild(resultText);             resultsElement.appendChild(resultDiv);         }     }      provideFeedback(message) {         document.querySelector('#feedback').textContent = message;     }      initialize() {         const userElement = document.querySelector('#user');         if (userElement) {             userElement.textContent = 'Current user: ' + this.user;         }         this.displayBackfilledResults(); // Display the initial results          // Add event listeners         document.querySelector("#startPlayingButton").addEventListener('click', () => this.startPlaying());         document.querySelector("#switchUserButton").addEventListener('click', () => this.switchUser());         document.querySelector("#backfillResultsButton").addEventListener('click', () => this.backfillResults());     } }</sentence4>
<sentence5>Getting this error in the browser caught SyntaxError: Unexpected token 'export' - game.js: 1   game.js export default class Game {     constructor() {         this.user = this.getUser();         this.initialize();     }      startPlaying() {         var rikishi = document.querySelector('#rikishi').value;         var picks = this.getPicks();         var message = "You selected: " + rikishi + "\nPrevious Picks: " + JSON.stringify(picks);         this.updatePicks(rikishi); // Update the picks with the new selection         return message;     }      getUser() {         // get user from local storage         var user = localStorage.getItem('user');         if (!user) {             user = 'admin';             localStorage.setItem('user', user);         }         return user;     }      getPicks() {         var picks = JSON.parse(localStorage.getItem(this.user));         if (!picks) {             picks = {};         }         return picks;     }      updatePicks(rikishi) {         var picks = this.getPicks();         var currentContest = new Date().getMonth();         if ([0, 2, 4, 6, 8, 10].includes(currentContest)) {             var contestName = new Date().toLocaleString('default', { month: 'long' }) + ' ' + new Date().getFullYear();             picks[contestName] = rikishi;             localStorage.setItem(this.user, JSON.stringify(picks));         }     }      switchUser() {         var newUser = document.querySelector('#userSwitch').value;         localStorage.setItem('user', newUser);         document.querySelector('#user').textContent = 'Current user: ' + newUser;         this.user = newUser;     }      backfillResults() {         var contestName = document.querySelector('#backfillContest').value;         var rikishi = document.querySelector('#backfillRikishi').value;         var picks = this.getPicks();         picks[contestName] = rikishi;         localStorage.setItem(this.user, JSON.stringify(picks));     }      initialize() {         var userElement = document.querySelector('#user');         if (userElement) {             userElement.textContent = 'Current user: ' + this.user;         }     } }  function initGame() {   const game = new Game();    document.querySelector("#startPlayingButton").addEventListener('click', () => game.startPlaying());   document.querySelector("#switchUserButton").addEventListener('click', () => game.switchUser());   document.querySelector("#backfillResultsButton").addEventListener('click', () => game.backfillResults()); }  if (typeof window !== 'undefined') {     window.onload = initGame; }</sentence5>
<sentence6>When I am playing the game in the browser I get module is not defined (game.js line 63)  index.html        Banzuke Surfing Game                     -->       Welcome to Banzuke Surfing Game!          Select your Rikishi and start playing!              Rikishi 1         Rikishi 2                   Start Playing          Admin Panel     Switch user:          Switch User     Backfill contest results:               Backfill Results              game.js function startPlaying() {     var rikishi = document.querySelector('#rikishi').value;     var user = getUser();     var picks = getPicks(user);     var message = "You selected: " + rikishi + "\nPrevious Picks: " + JSON.stringify(picks);     updatePicks(user, rikishi); // Update the picks with the new selection     return message; }  function getUser() {     // get user from local storage     var user = localStorage.getItem('user');     if (!user) {         user = 'admin';         localStorage.setItem('user', user);     }     return user; }  function getPicks(user) {     var picks = JSON.parse(localStorage.getItem(user));     if (!picks) {         picks = {};     }     return picks; }  function updatePicks(user, rikishi) {     var picks = getPicks(user);     var currentContest = new Date().getMonth();     if ([0, 2, 4, 6, 8, 10].includes(currentContest)) {         var contestName = new Date().toLocaleString('default', { month: 'long' }) + ' ' + new Date().getFullYear();         picks[contestName] = rikishi;         localStorage.setItem(user, JSON.stringify(picks));     } }  function switchUser() {     var newUser = document.querySelector('#userSwitch').value;     localStorage.setItem('user', newUser);     document.querySelector('#user').textContent = 'Current user: ' + newUser;; }  function backfillResults() {     var user = getUser();     var contestName = document.querySelector('#backfillContest').value;     var rikishi = document.querySelector('#backfillRikishi').value;     var picks = getPicks(user);     picks[contestName] = rikishi;     localStorage.setItem(user, JSON.stringify(picks)); }  function initialize() {     var user = getUser();     var userElement = document.querySelector('#user');     if (userElement) {         userElement.textContent = 'Current user: ' + user;     } }  initialize();  module.exports = { startPlaying, switchUser, backfillResults, initialize };</sentence6>
<sentence7>None of the localStorage stuff renders on the page, although I can open the debugging console and verify that it's there.  I don't know if this console error is related: Error with Permissions-Policy header: Origin trial controlled feature not enabled: 'interest-cohort'.  index.html        Banzuke Surfing Game                     -->       Welcome to Banzuke Surfing Game!          Select your Rikishi and start playing!              Rikishi 1         Rikishi 2                   Start Playing          Backfilled Results:          Admin Panel     Switch user:          Switch User     Backfill contest results:               Backfill Results                   game.js export default class Game {     constructor() {         this.user = this.getUser();         this.initialize();     }      startPlaying() {         var rikishi = document.querySelector('#rikishi').value;         var picks = this.getPicks();         var message = "You selected: " + rikishi + "\nPrevious Picks: " + JSON.stringify(picks);         this.updatePicks(rikishi); // Update the picks with the new selection         return message;     }      getUser() {         // get user from local storage         var user = localStorage.getItem('user');         if (!user) {             user = 'admin';             localStorage.setItem('user', user);         }         return user;     }      getPicks() {         var picks = JSON.parse(localStorage.getItem(this.user));         if (!picks) {             picks = {};         }         return picks;     }      updatePicks(rikishi) {         var picks = this.getPicks();         var currentContest = new Date().getMonth();         if ([0, 2, 4, 6, 8, 10].includes(currentContest)) {             var contestName = new Date().toLocaleString('default', { month: 'long' }) + ' ' + new Date().getFullYear();             picks[contestName] = rikishi;             localStorage.setItem(this.user, JSON.stringify(picks));         }     }      switchUser() {         var newUser = document.querySelector('#userSwitch').value;         localStorage.setItem('user', newUser);         document.querySelector('#user').textContent = 'Current user: ' + newUser;         this.user = newUser;     }      backfillResults() {         var contestName = document.querySelector('#backfillContest').value;         var rikishi = document.querySelector('#backfillRikishi').value;         var picks = this.getPicks();         picks[contestName] = rikishi;         localStorage.setItem(this.user, JSON.stringify(picks));         this.provideFeedback('Backfilled results for ' + contestName + ' with ' + rikishi); // Provide feedback         this.displayBackfilledResults(); // Display the updated results     }      displayBackfilledResults() {         var picks = this.getPicks();         var resultsElement = document.querySelector('#backfilledResults');          // Clear previous results         resultsElement.textContent = '';          // Display each contest result         for (var contest in picks) {             var rikishi = picks[contest];             var resultText = document.createTextNode(contest + ': ' + rikishi);             var resultDiv = document.createElement('div');             resultDiv.appendChild(resultText);             resultsElement.appendChild(resultDiv);         }     }      provideFeedback(message) {         document.querySelector('#feedback').textContent = message;     }      initialize() {         var userElement = document.querySelector('#user');         if (userElement) {             userElement.textContent = 'Current user: ' + this.user;         }         this.displayBackfilledResults(); // Display the initial results     } }  function initGame() {   const game = new Game();    document.querySelector("#startPlayingButton").addEventListener('click', () => game.startPlaying());   document.querySelector("#switchUserButton").addEventListener('click', () => game.switchUser());   document.querySelector("#backfillResultsButton").addEventListener('click', () => game.backfillResults()); }  if (typeof window !== 'undefined') {     window.onload = initGame; }</sentence7>
<sentence8>ok the console errors are gone but nothing renders when i backfill - I need something to look at besides the name of the current user  index.html        Banzuke Surfing Game                     -->       Welcome to Banzuke Surfing Game!          Select your Rikishi and start playing!              Rikishi 1         Rikishi 2                   Start Playing          Admin Panel     Switch user:          Switch User     Backfill contest results:               Backfill Results              game.js export default class Game {     constructor() {         this.user = this.getUser();         this.initialize();     }      startPlaying() {         var rikishi = document.querySelector('#rikishi').value;         var picks = this.getPicks();         var message = "You selected: " + rikishi + "\nPrevious Picks: " + JSON.stringify(picks);         this.updatePicks(rikishi); // Update the picks with the new selection         return message;     }      getUser() {         // get user from local storage         var user = localStorage.getItem('user');         if (!user) {             user = 'admin';             localStorage.setItem('user', user);         }         return user;     }      getPicks() {         var picks = JSON.parse(localStorage.getItem(this.user));         if (!picks) {             picks = {};         }         return picks;     }      updatePicks(rikishi) {         var picks = this.getPicks();         var currentContest = new Date().getMonth();         if ([0, 2, 4, 6, 8, 10].includes(currentContest)) {             var contestName = new Date().toLocaleString('default', { month: 'long' }) + ' ' + new Date().getFullYear();             picks[contestName] = rikishi;             localStorage.setItem(this.user, JSON.stringify(picks));         }     }      switchUser() {         var newUser = document.querySelector('#userSwitch').value;         localStorage.setItem('user', newUser);         document.querySelector('#user').textContent = 'Current user: ' + newUser;         this.user = newUser;     }      backfillResults() {         var contestName = document.querySelector('#backfillContest').value;         var rikishi = document.querySelector('#backfillRikishi').value;         var picks = this.getPicks();         picks[contestName] = rikishi;         localStorage.setItem(this.user, JSON.stringify(picks));     }      initialize() {         var userElement = document.querySelector('#user');         if (userElement) {             userElement.textContent = 'Current user: ' + this.user;         }     } }  function initGame() {   const game = new Game();    document.querySelector("#startPlayingButton").addEventListener('click', () => game.startPlaying());   document.querySelector("#switchUserButton").addEventListener('click', () => game.switchUser());   document.querySelector("#backfillResultsButton").addEventListener('click', () => game.backfillResults()); }  if (typeof window !== 'undefined') {     window.onload = initGame; }</sentence8>
<sentence9>const fs = require('fs'); const multer = require('multer'); const puppeteer = require('puppeteer'); const express = require('express'); const app = express(); const port = 3001; const path = require('path'); const storage = multer.diskStorage({   destination: function(req, file, cb) {     cb(null, 'uploads/')   },   filename: function(req, file, cb) {     const date = new Date();     const formattedDate = `${date.getFullYear()}${date.getMonth() + 1}${date.getDate()}${date.getHours()}${date.getMinutes()}${date.getSeconds()}`;     const fileName = `${formattedDate}_${file.originalname}`;     cb(null, fileName);   } }); const upload = multer({ storage: storage }); const serveIndex = require('serve-index');  // app.use('/generated', express.static(path.join(__dirname, 'generated')), serveIndex(path.join(__dirname, 'generated'), {'icons': true})); // app.use('/uploads', express.static(path.join(__dirname, 'uploads')), serveIndex(path.join(__dirname, 'uploads'), {'icons': true}));  app.post('/api/upload', upload.single('file'), (req, res) => {   const {bookName, fontSize, papersCount} = req.query;    const date = new Date();   const id = `${date.getFullYear()}${date.getMonth() + 1}${date.getDate()}${date.getHours()}${date.getMinutes()}${date.getSeconds()}_${bookName}_${fontSize}`;    function writeToInProgress(text) {     console.log(`${text}`);     const inProgressPath = path.join(__dirname, 'generated', `IN_PROGRESS_${id}.txt`);     fs.writeFileSync(inProgressPath, text);   }    setImmediate(async () => {     try {       await run(req, id, bookName, fontSize);     } catch (error) {       console.error(error);       writeToInProgress('ERROR: ' + error.toString());     }   });    async function run(req, id, bookName, fontSize) {     const browser = await puppeteer.launch({       protocolTimeout: 1000000     });     const page = await browser.newPage();     const inProgressPath = path.join(__dirname, 'generated', `IN_PROGRESS_${id}.txt`);      page.on('console', pageIndex => {       writeToInProgress(`Creating sheet ${pageIndex.text() / 2} of ${papersCount}-ish.`);     });      // await page.setViewport({ width: 816, height: 1056 });      let text = fs.readFileSync(req.file.path, 'utf8');          await page.goto(`file://${__dirname}/page.html`);          await page.addStyleTag({content: `body { font-size: ${fontSize}px; }`});      writeToInProgress(`Creating: ${bookName}`);      await page.evaluate((text, bookName) => {       let pageIndex = 0;       const words = text.split(' ');       let blocks = [];       let currentBlockIndex = 0;       let currentBlock;       let isCurrentPageFront = true; // tracks whether the next page to be rendered is on the front of the double sided sheet. the side with the big header        function createNewPage(wordsLeft) {         console.log(pageIndex+1);         const page = document.createElement('div');         page.className = 'page';          // create grid cells         const grid = document.createElement('div');         grid.className = 'grid-container';         for (let i = 0; i = 4 && i  currentBlock.clientHeight) {           currentBlock.innerHTML = currentBlock.innerHTML.slice(0, currentBlock.innerHTML.length - words[i].length);            // Move to the next block           currentBlockIndex++;           if (currentBlockIndex >= blocks.length) {             createNewPage(words.length - i); // Create a new page if all blocks are filled             currentBlockIndex = blocks.length - 16; // Reset the block index to the first block of the new page           }           currentBlock = blocks[currentBlockIndex];           currentBlock.innerHTML += ' ' + words[i]; // Add the word to the new block         }       }        // Populate headers       const SHEETS_AMOUNT = Math.ceil(pageIndex / 2);       isCurrentPageFront = true;       for (let i = 0; i  {         const cloneBlock = block.cloneNode(true);         const spanElement = cloneBlock.querySelector('.miniSheetNum');         if (spanElement) {           spanElement.remove();         }         if (cloneBlock.textContent.trim() === '') {           block.remove();         }       });     }, text, bookName);      writeToInProgress('Finished creating pages. Writing to file...');      let htmlContent = await page.content();     const pageHtml = path.join(__dirname, `pageHtml.html`);     fs.writeFileSync(pageHtml, htmlContent);      const pdf = await page.pdf({ format: 'Letter' });     const pdfOutput = path.join(__dirname, 'generated', `${id}.pdf`);     fs.writeFileSync(pdfOutput, pdf);      await browser.close();      // Delete the IN_PROGRESS file after PDF is created     if (fs.existsSync(inProgressPath)) {       fs.unlinkSync(inProgressPath);     }   }      res.json({ message: 'PDF creation started.', id }); });  app.get('/api/download/', (req, res) => {   const { id } = req.query;   const pdfOutput = path.join(__dirname, 'generated', `${id}.pdf`);   const inProgressPath = path.join(__dirname, 'generated', `IN_PROGRESS_${id}.txt`);    if (fs.existsSync(pdfOutput)) {     res.redirect(`/generated/${id}.pdf`);   } else if (fs.existsSync(inProgressPath)) {     res.send(fs.readFileSync(inProgressPath, 'utf8'));   } else {     return res.send('Not started. It\'s either in the queue, or failed entirely.');   } });  app.listen(port, () => {   console.log(`Listening on port ${port}`); });  how can i improve the performance of this program</sentence9>


The topic is described by the following keywords: localstoragesetitemthisuser, localstoragesetitemuser, gamejs, javascript, getuser, userelement, banzuke, rikishi, reactdomdevelopmentjs20279, reactdomdevelopmentjs21794,

Based on the information about the topic above, 
1) Analyze the keywords and come up with a general label. Explain why? 
2) cluster the most representative sentences to come up with sub-labels. Explain why? 

DO NOT FORGET TO include the first 10 character of that sentences that you use to come up with that sub-category, so that I can read the sentences you have clustered and see if you come up with correct label for that. 
Take your time and think, then come up with the best, precise, and meaningful label and sub-labels.

Now Take a deep breath and start